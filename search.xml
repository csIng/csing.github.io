<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[APT简记]]></title>
    <url>%2Fposts%2Fd847228d%2F</url>
    <content type="text"><![CDATA[APTAPT全称是：Annotation Processing Tool1. 什么是注解：从JDK5开始,Java增加对元数据的支持，也就是注解，注解与注释是有一定区别的，可以把注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过注解开发人员可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息。 2. 注解的独立性​ Annotation本身不影响程序代码的执行，保持其独立性。 3. 注解的分类：​ （1） 元注解 ​ 被用来定义注解的注解。 ​ @Retention，@Target，@Documented，@Inherited。 ​ （2） 标准注解 ​ @Override,@Deprecated,@SuppressWarnings,@SafeVarargs,@FunctionalInterface ​ （3）自定义注解 ​ 如何自定义一个注解？ 123456789101112131415161718package butterknife;import androidx.annotation.IdRes;import java.lang.annotation.Retention;import java.lang.annotation.Target;import static java.lang.annotation.ElementType.FIELD;import static java.lang.annotation.RetentionPolicy.RUNTIME;/** * Bind a field to the view for the specified ID. The view will automatically be cast to the field */@Retention(RUNTIME) /**如果不写，默认是CLASS级别*/@Target(FIELD) /**如果不写，默认是所有类型*/public @interface BindView &#123; /** View ID to which the field will be bound. */ @IdRes int value();&#125; @Retention用来修饰这是一个什么类型的注解，以及APT在何时处理这个注解。 @Retention的三种类型 1234567891011121314151617181920212223242526272829/** * Annotation retention policy. The constants of this enumerated type * describe the various policies for retaining annotations. They are used * in conjunction with the &#123;@link Retention&#125; meta-annotation type to specify * how long annotations are to be retained. * * @since 1.5 */public enum RetentionPolicy &#123; /** * Annotations are to be discarded by the compiler. */ SOURCE, /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. */ CLASS, /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * * @see java.lang.reflect.AnnotatedElement */ RUNTIME&#125; RUNTIME级别的RetentionPolicy可以在CLASS级别使用吗？ @Target用来表示这个注解可以使用在哪些地方。比如：类、方法、属性、接口等。可修饰多个。 @Target类型 123456789101112131415161718192021222324252627282930313233343536373839404142 /* * @since 1.5 */public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE&#125; 4. 注解的定义1public @interface BindView 仅可用public 和缺省来修饰，不可用protected和private 5. 注解方法声明1@IdRes int value(); （1） 无参 （2） 方法不能抛异常； （3） 返回值类型： 只能使用基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组。 （4） 默认值 ​ 方法可以有默认返回值，没有默认返回值的方法必须在使用注解时设置值； ​ int value() default 0; 6. 注解的使用1@BindView(R.id.fab) FloatingActionButton fab; 7. 如何从注解中获取信息(1) 通过反射 1234567891011121314151617181920public static void bind(final Activity target)&#123; bindViews(target, target.getClass().getDeclaredFields(), target.getWindow().getDecorView()&#125;private static void bindViews(final Object obj, Field[] fields, View rootView)&#123; for(final Field field : fields) &#123; Annotation annotation = field.getAnnotation(BindView.class); if (annotation != null) &#123; BindView bindView = (BindView) annotation; int id = bindView.value(); View view = rootView.findViewById(id); try &#123; field.setAccessible(true); field.set(obj, view); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; (2) 编译时注解 8.编译时注解的项目搭建(1) 添加注解AptAnnotationLibrary(JavaLibrary)，并添加注解： 12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface BindView &#123; int value();&#125; (2) 添加注解处理器AptProcessorLibrary(JavaLibrary) 12345@AutoService(Processor.class)@SupportedSourceVersion(SourceVersion.RELEASE_8)public class BindProcessor extends AbstractProcessor &#123;&#125; 12&gt; implementation 'com.google.auto.service:auto-service:1.0-rc4'&gt; @AutoService(Processor.class)用于自动生成META-INF信息，告诉编译器处理该Processor，作用等同如下： `@SupportedSourceVersion(SourceVersion.RELEASE_8)用于告诉编译器该Processor支持的版本 9. BindProcessor中需要执行的操作：（1）告诉该处理器支持的注解： 123456@Overridepublic Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; result = new HashSet&lt;&gt;(); result.add(BindView.class.getCanonicalName()); return result;&#125; （2） 处理编译器通知的注解信息： 12345@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123; parseBindElements(roundEnvironment.getElementsAnnotatedWith(BindView.class)); return doProcess();&#125; （3）解析注解信息，并将注解信息放入elements集合中： 12&gt; private Map&lt;TypeElement, Set&lt;Element&gt;&gt; elements;&gt; 123456789101112131415private void parseBindElements(Set&lt;? extends Element&gt; bindElements) &#123; if (bindElements == null || bindElements.isEmpty()) &#123; return; &#125; for (Element element : bindElements) &#123; TypeElement enclosingElement = (TypeElement) element.getEnclosingElement(); Set&lt;Element&gt; set = elements.get(enclosingElement); if (set == null) &#123; set = new HashSet&lt;&gt;(); elements.put(enclosingElement, set); &#125; set.add(element); System.out.println("Add element :element name:" + element.getSimpleName() + "\tenclosingElement name:"+enclosingElement.getSimpleName()); &#125; (4) 处理注解信息并生成代码： 生成的代码： 123456789&gt; package com.csdroid.demo.apt;&gt; &gt; public final class MainActivityBind extends MainActivity &#123;&gt; public static void bind(MainActivity activity) &#123;&gt; activity.tvContent = (android.widget.TextView)activity.findViewById(2131230913);&gt; activity.fab = (android.support.design.widget.FloatingActionButton)activity.findViewById(2131230789);&gt; &#125;&gt; &#125;&gt; 12345678910111213private boolean doProcess() &#123; if (elements.isEmpty()) &#123; return false; &#125; for (TypeElement enclosingElement : elements.keySet()) &#123; MethodSpec methodSpec = generateMethodSpec(enclosingElement); TypeSpec typeSpec = generateTypeSpec(enclosingElement, methodSpec); generateJavaFile(enclosingElement, typeSpec); &#125; return true;&#125; 12&gt; implementation 'com.squareup:javapoet:1.10.0'&gt; (5) 生成方法： 1234567891011private MethodSpec generateMethodSpec(TypeElement enclosingElement) &#123; MethodSpec.Builder builder = MethodSpec.methodBuilder("bind") .addModifiers(Modifier.PUBLIC, Modifier.STATIC) .addParameter(ClassName.get(enclosingElement.asType()), "activity") .returns(TypeName.VOID); Set&lt;Element&gt; bindSet = elements.get(enclosingElement); for (Element element : bindSet) &#123; builder.addStatement(String.format(Locale.US,"activity.%s = (%s)activity.findViewById(%d)", element.getSimpleName(), element.asType(), element.getAnnotation(BindView.class).value())); &#125; return builder.build();&#125; (6) 生成类： 1234567private TypeSpec generateTypeSpec(TypeElement enclosingElement, MethodSpec methodSpec) &#123; return TypeSpec.classBuilder(enclosingElement.getSimpleName() + "Bind") .superclass(TypeName.get(enclosingElement.asType())) .addModifiers(Modifier.FINAL, Modifier.PUBLIC) .addMethod(methodSpec) .build();&#125; (7) 生成同包名下的java文件： 12345678910private boolean generateJavaFile(TypeElement enclosingElement, TypeSpec typeSpec) &#123; JavaFile javaFile = JavaFile.builder(elementUtils.getPackageOf(enclosingElement).getQualifiedName().toString(), typeSpec).build(); try &#123; javaFile.writeTo(processingEnv.getFiler()); return true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return false;&#125; 此时将AptProcessor加入App依赖库后编译即可看到生成的代码； 代码目录：.AptDemo/app/build/generated/source/apt/debug/com/csdroid/demo/apt/MainActivityBind.java 12&gt; annotationProcessor project(&apos;:AptProcessor&apos;)&gt; (8) 如何使用？1234567891011121314151617181920212223public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.fab) public FloatingActionButton fab; @BindView(R.id.tv_content) public TextView tvContent; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Bind.bind(this); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar.make(view, "Replace with your own action", Snackbar.LENGTH_LONG) .setAction("Action", null).show(); tvContent.setText("Action"); &#125; &#125;); &#125;&#125; 此部分是BindView在App中的使用 (9) 如何建立App和生成代码间的联系？创建AptApi android library，并提供bind接口供外部调用： 123456789101112131415161718192021222324252627282930public class Bind &#123; public static Map&lt;Class, Method&gt; binds = new HashMap&lt;&gt;(); public static void bind(Activity activity) &#123; if (activity == null || activity.isFinishing()) &#123; return; &#125; Method method = binds.get(activity.getClass()); if (method == null) &#123; Package pack = activity.getClass().getPackage(); if (pack == null) &#123; return; &#125; String className = pack.getName() + "." + activity.getClass().getSimpleName() + "Bind"; try &#123; Class bindClass = Class.forName(className); method = bindClass.getMethod("bind", activity.getClass()); binds.put(activity.getClass(), method); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; try &#123; if (method != null) &#123; method.invoke(null, activity); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; App工程依赖AptApi library implementation project(&#39;:AptApi&#39;) Demo源码：https://github.com/csIng/BindView]]></content>
      <categories>
        <category>研究</category>
      </categories>
      <tags>
        <tag>APT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ExoPlayer缓冲策略（三）]]></title>
    <url>%2Fposts%2F93a28bc9%2F</url>
    <content type="text"><![CDATA[ExoPlayer是根据什么策略来缓冲媒体数据的？ 在之前的文章中我们描述过，LoadControl是控制媒体数据缓冲的，它有一个默认的实现DefaulLoadControl,默认的缓冲策略就在其中。 默认参数信息缓冲策略控制需要基于一定的数据基础，根据数据来确定是否满足一定的条件（是否可以缓冲，是否可以播放等），以下是在DefaultLoadControl中定义的初始信息： 123456789101112131415161718// 播放开始后，播放器缓冲的最小缓冲时间。public static final int DEFAULT_MIN_BUFFER_MS = 15000;// 播放开始后，播放器缓冲的最大缓冲时间(DEFAULT_PRIORITIZE_TIME_OVER_SIZE_THRESHOLDS为true时)public static final int DEFAULT_MAX_BUFFER_MS = 50000;// 播放前需缓冲的最小时间public static final int DEFAULT_BUFFER_FOR_PLAYBACK_MS = 2500;// rebuffer后播放器播放时需要缓冲的最小时间// A rebuffer is defined to be caused by buffer depletion rather than a user action.public static final int DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS = 5000;// 默认的缓冲大小，当设置为C.LENGTH_UNSET时，由加载控制器自动检测目标大小public static final int DEFAULT_TARGET_BUFFER_BYTES = C.LENGTH_UNSET;// 缓冲时间优先级是否大于缓冲大小优先级。public static final boolean DEFAULT_PRIORITIZE_TIME_OVER_SIZE_THRESHOLDS = true; 默认加载控制器如何控制缓冲继续缓冲 当缓冲时间为高优先级时： 未达到最小缓冲时间； 当缓冲大小为高优先级时： 未达到最小缓冲时间，并且未达到目标缓冲大小。 停止缓冲 已缓冲时间超过了设置的最大缓冲时间； 超过最小缓冲时间：达到最大缓冲大小； 当设置了缓存大小为高优先级，即使未达到最小缓冲时间，但达到了最大缓冲大小。 详细实现如下： 123456789101112131415161718192021222324252627@Overridepublic boolean shouldContinueLoading(long bufferedDurationUs, float playbackSpeed) &#123; boolean targetBufferSizeReached = allocator.getTotalBytesAllocated() &gt;= targetBufferSize; boolean wasBuffering = isBuffering; long minBufferUs = this.minBufferUs; if (playbackSpeed &gt; 1) &#123; // 当播放速率变大时，最小缓冲时间需要重新计算(Math.round((double) playoutDuration * speed);) long mediaDurationMinBufferUs = Util.getMediaDurationForPlayoutDuration(minBufferUs, playbackSpeed); minBufferUs = Math.min(mediaDurationMinBufferUs, maxBufferUs); &#125; // 判断缓冲时间并根据优先级处理。 if (bufferedDurationUs &lt; minBufferUs) &#123; isBuffering = prioritizeTimeOverSizeThresholds || !targetBufferSizeReached; &#125; else if (bufferedDurationUs &gt; maxBufferUs || targetBufferSizeReached) &#123; // 判断最大缓冲时间和目标缓冲大小。 isBuffering = false; &#125; // Else don't change the buffering state if (priorityTaskManager != null &amp;&amp; isBuffering != wasBuffering) &#123; if (isBuffering) &#123; priorityTaskManager.add(C.PRIORITY_PLAYBACK); &#125; else &#123; priorityTaskManager.remove(C.PRIORITY_PLAYBACK); &#125; &#125; return isBuffering;&#125; 如何计算目标缓冲大小目标缓冲大小是判断是否继续缓冲的一个很重要的参数，它是如何计算的呢？ 当设置了DEFAULT_TARGET_BUFFER_BYTES = C.LENGTH_UNSET; 需要计算期待达到的目标缓冲大小： 12345678910// 轨道选择器准备就绪，调用此方法。@Overridepublic void onTracksSelected(Renderer[] renderers, TrackGroupArray trackGroups, TrackSelectionArray trackSelections) &#123; targetBufferSize = targetBufferBytesOverwrite == C.LENGTH_UNSET ? calculateTargetBufferSize(renderers, trackSelections) : targetBufferBytesOverwrite; allocator.setTargetBufferSize(targetBufferSize);&#125; 重点在于calculateTargetBufferSize 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Calculate target buffer size in bytes based on the selected tracks. The player will try not to * exceed this target buffer. Only used when &#123;@code targetBufferBytes&#125; is &#123;@link C#LENGTH_UNSET&#125;. * * @param renderers The renderers for which the track were selected. * @param trackSelectionArray The selected tracks. * @return The target buffer size in bytes. */protected int calculateTargetBufferSize( Renderer[] renderers, TrackSelectionArray trackSelectionArray) &#123; int targetBufferSize = 0; for (int i = 0; i &lt; renderers.length; i++) &#123; if (trackSelectionArray.get(i) != null) &#123; targetBufferSize += Util.getDefaultBufferSize(renderers[i].getTrackType()); &#125; &#125; return targetBufferSize;&#125;/** * Maps a &#123;@link C&#125; &#123;@code TRACK_TYPE_*&#125; constant to the corresponding &#123;@link C&#125; * &#123;@code DEFAULT_*_BUFFER_SIZE&#125; constant. * * @param trackType The track type. * @return The corresponding default buffer size in bytes. */public static int getDefaultBufferSize(int trackType) &#123; switch (trackType) &#123; case C.TRACK_TYPE_DEFAULT: return C.DEFAULT_MUXED_BUFFER_SIZE; case C.TRACK_TYPE_AUDIO: return C.DEFAULT_AUDIO_BUFFER_SIZE; case C.TRACK_TYPE_VIDEO: return C.DEFAULT_VIDEO_BUFFER_SIZE; case C.TRACK_TYPE_TEXT: return C.DEFAULT_TEXT_BUFFER_SIZE; case C.TRACK_TYPE_METADATA: return C.DEFAULT_METADATA_BUFFER_SIZE; default: throw new IllegalStateException(); &#125;&#125; 由上可以看到，目标缓冲大小的计算其实是根据默认的视频缓冲区/音频缓冲区等来确定的。 如何判断是否可以播放？该功能由shouldStartPlayback来实现： 12345678910@Overridepublic boolean shouldStartPlayback( long bufferedDurationUs, float playbackSpeed, boolean rebuffering) &#123; bufferedDurationUs = Util.getPlayoutDurationForMediaDuration(bufferedDurationUs, playbackSpeed); long minBufferDurationUs = rebuffering ? bufferForPlaybackAfterRebufferUs : bufferForPlaybackUs; return minBufferDurationUs &lt;= 0 || bufferedDurationUs &gt;= minBufferDurationUs || (!prioritizeTimeOverSizeThresholds &amp;&amp; allocator.getTotalBytesAllocated() &gt;= targetBufferSize);&#125; 满足的条件如下： 最小缓冲时间小于等于0； 缓冲时间达到了设置的最小缓冲时间； 以缓冲大小为优先级时，当前缓冲大小已达到了设置的目标缓冲大小。 综合以上，LoadControl控制器是针对缓冲和播放的策略控制；其主要根据缓冲时间和缓冲大小，并结合两者的优先级进行管理。另外在默认参数的设置上，根据该链接中的说明： There are arguments that mobile carriers prefer this kind of traffic pattern over their networks (i.e. bursts rather than drip-feeding). Which is an important consideration given ExoPlayer is used by some very popular services. It may also be more battery efficient. Whether these arguments are still valid is something we should probably take another look at fairly soon, since the information we used when making this decision is 3-4 years old now. We should also figure out whether we should adjust the policy dynamically based on network type (e.g. even if the arguments are still valid, they may only hold for mobile networks and not for WiFi). note：2016year. 目前的参数设置应该根据网络类型及不同的场景动态设置。 在最近(20180309)的更新中,官方人员已将maxBuffered设置为50000ms，其commit说明如下： The value is increased to 50 seconds. With that the player can better handle short network problems. This does NOT increase the maximum memory used as we still apply the seperate DEFAULT_TARGET_BUFFER_BYTES. 在以上的描述中，涉及到两个重要的方法shouldContinueLoading和shouldStartPlayback,它们是在什么样的场景下触发的？ shouldContinueLoading的触发时机shouldContinueLoading的调用是在ExoPlayerImplInternal中； Period prepared/update; Tracker reselcted; Seek to target position; Media source refresh. 以上都是在播放器播放未结束的前提条件下。 shouldStartPlayback的触发时机在ExoPlayerImplInternal中的doSomeWork()时，shouldStartPlayback是播放器的状态从STATE_BUFFERING切换到STATE_READY时需满足的一个条件。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>ExoPlayer</tag>
        <tag>缓冲</tag>
        <tag>策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《无声告白》]]></title>
    <url>%2Fposts%2F30146431%2F</url>
    <content type="text"><![CDATA[我们终此一生，就是要摆脱他人的期待，找到真正的自己！ 我们终此一生，就是要摆脱他人的期待，找到真正的自己！ 莉迪亚的生命很短暂，在她短暂的生命终点，她找到了真正的自己。如果收获一个果实需要付出很多，那么这个代价有点太沉重了。 全书围绕莉迪亚的死亡展开描述，读起来让人倍感压抑。但又于这压抑中，慢慢的竟有生的希望，犹如老树发芽。 在莉迪亚的身上，他寄托了父亲和母亲未达成的梦想，而这梦想犹如淹死她的湖水将她一步步拖入深渊，最后不堪重负。在杰克的引导下，她最终找到了自己，但却没有游出象征着她迈出人生重要一步的湖泊。作者多次强调，湖水犹如父母的梦想，将她包围。她最终溺亡，是否暗示了她即使游出湖，也无法摆脱父母的期待，做真正的自己。令人欣慰的是，她找到了真正的自己。 在目前中国的大多数家庭中，很多的父母将其未完成的梦想寄托于儿女，希望儿女能实现。每个人都有自己的一生，导演和编剧都是自己，你演不好自己的戏，也不要让别人来替你演，因为他们有自己的舞台。 莉迪亚的溺亡，犹如初春的柳条狠狠的甩在宁静的湖面，击飞浮尘的同时，也露出了清澈的湖面，该书的最后，家里的每一个人都找到了真正的自己。 书中让我惊讶的是儿女们敏锐的洞察力，他们洞悉隐藏在表面的真相，并试图用自己微弱的力量温暖这个家。 本书值得一看，尤其在于对儿女教育观念的转变及对自身未来的探索。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>无声告白</tag>
        <tag>书</tag>
        <tag>有感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ExoPlayer视频播放流程简析（二）]]></title>
    <url>%2Fposts%2Fd1d54cc7%2F</url>
    <content type="text"><![CDATA[ExoPlayer播放视频的流程是什么样的？在整个视频播放的过程中，它是如何进行的？ ExoPlayer在设计视频播放时定义了很多视频相关的接口，以使该框架灵活性和扩展性更好，在主要的Player和ExoPlayer中都定义了哪些通用的接口和方法呢？ 源码参考r2.8.1版本。 Player定义的功能： 视频事件监听接口EventListener 加载状态监听； 播放状态监听； 时间轴变化； 轨道变化； 视频参数变化； seek状态变化； 重放模式监听； 播放异常信息监听； 视频组件； 字幕组件； 视频播放控制（开始，暂停，停止）； 视频参数设置； 广告相关； ExoPlayer定义的功能：ExoPlayer实现了Player,在Player功能的基础上增加了如下特性： 其它线程和播放线程的通信； 媒体资源的准备接口； Player中定义的都是和视频本身事件相关的接口；而在ExoPlayer中定义了和上层通信的接口以及为上层视频播放提供资源的接口；ExoPlayer为上层提供了交互的桥梁； ExoPlayerImpl功能实现：ExoPlayerImpl是ExoPlayer的实现，但它仅提供了简单实现： 对外提供视频播放的基本信息； 对ExoPlayer的真正实现ExoPlayerImplInternal的封装; Q: 为什么不由ExoPlayerImpl直接提供对ExoPlayer的实现呢？反而交由ExoPlayerImplInternal来完成。 A: 在ExoPlayerImplInternal的内部实现中，是通过handler机制将视频播放的事件发送到独立的线程中运行。由ExoPlayerImplInternal来完全处理播放相关事件的发送和实现；通过该方式达到业务的实现和状态（提供给上层的接口）分离。接口的使用者根本不用关心其内部是如何实现的，并且也不应该将其实现暴漏给接口调用者。后续若有需求/实现的变更，仅修改对应的部分即可，互不影响。 ExoPlayerImplInternal部分实现 在构建ExoPlayerImplInternal对象时，传入了渲染器，轨道选择器， 加载控制器等参数用于为后续的视频播放提供支持； 通过prepare方法为视频播放提供播放的视频源，内部实现是通过handler将该操作发送到播放线程执行， 12345public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) &#123; handler .obtainMessage(MSG_PREPARE, resetPosition ? 1 : 0, resetState ? 1 : 0, mediaSource) .sendToTarget();&#125; 在播放线程中接收消息： 1234567891011public boolean handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_PREPARE: prepareInternal( (MediaSource) msg.obj, /* resetPosition= */ msg.arg1 != 0, /* resetState= */ msg.arg2 != 0); break; ... &#125;&#125; 处理消息： 1234567891011121314151617private void prepareInternal(MediaSource mediaSource, boolean resetPosition, boolean resetState) &#123; // 标示进入就绪状态的个数； // 若该值&gt;0,则认为针对新的MediaSource的timeline还没有初始化完成，部分操作将进入就绪状态。 // 当timeline更新或者plyer stop时会被重置。 pendingPrepareCount++; // 重置（清除MSG_DO_SOME_WORK；停止渲染并创建新的渲染器；清除就绪队列；重置状态；重置mediasource等信息） resetInternal(/* releaseMediaSource= */ true, resetPosition, resetState); // 通知重置加载控制器 loadControl.onPrepared(); this.mediaSource = mediaSource; // 由于有了新的MediaSource，需要重置状态； setState(Player.STATE_BUFFERING); // 通知MediaSource的实现准备数据源； mediaSource.prepareSource(player, /* isTopLevelSource= */ true, /* listener= */ this); // 通知播放线程开始工作。 handler.sendEmptyMessage(MSG_DO_SOME_WORK);&#125; 准备工作完成后，后续的工作交给了MSG_DO_SOME_WORK，最终实现为doSomeWork: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091private void doSomeWork() throws ExoPlaybackException, IOException &#123; long operationStartTimeMs = clock.uptimeMillis(); // 更新缓冲/播放时间 updatePeriods(); // 若队列中没有需要播放的资源，则在间隔PREPARING_SOURCE_INTERVAL_MS时间后重复检测。 if (!queue.hasPlayingPeriod()) &#123; // We're still waiting for the first period to be prepared. maybeThrowPeriodPrepareError(); scheduleNextWork(operationStartTimeMs, PREPARING_SOURCE_INTERVAL_MS); return; &#125; MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod(); TraceUtil.beginSection("doSomeWork"); // 更新播放（渲染）/缓冲位置； updatePlaybackPositions(); long rendererPositionElapsedRealtimeUs = SystemClock.elapsedRealtime() * 1000; // 丢弃指定位置/关键帧之前的缓冲； playingPeriodHolder.mediaPeriod.discardBuffer(playbackInfo.positionUs - backBufferDurationUs,retainBackBufferFromKeyframe); boolean renderersEnded = true; boolean renderersReadyOrEnded = true; // 此处检查渲染是否就绪，及渲染是否结束； for (Renderer renderer : enabledRenderers) &#123; // TODO: Each renderer should return the maximum delay before which it wishes to be called // again. The minimum of these values should then be used as the delay before the next // invocation of this method. renderer.render(rendererPositionUs, rendererPositionElapsedRealtimeUs); renderersEnded = renderersEnded &amp;&amp; renderer.isEnded(); // Determine whether the renderer is ready (or ended). We override to assume the renderer is // ready if it needs the next sample stream. This is necessary to avoid getting stuck if // tracks in the current period have uneven durations. See: // https://github.com/google/ExoPlayer/issues/1874 boolean rendererReadyOrEnded = renderer.isReady() || renderer.isEnded() || rendererWaitingForNextStream(renderer); if (!rendererReadyOrEnded) &#123; renderer.maybeThrowStreamError(); &#125; renderersReadyOrEnded = renderersReadyOrEnded &amp;&amp; rendererReadyOrEnded; &#125; if (!renderersReadyOrEnded) &#123; maybeThrowPeriodPrepareError(); &#125; long playingPeriodDurationUs = playingPeriodHolder.info.durationUs; // 所有的渲染已经结束则停止渲染（@todo playingPeriodDurationUs &lt;= playbackInfo.positionUs ？） if (renderersEnded &amp;&amp; (playingPeriodDurationUs == C.TIME_UNSET || playingPeriodDurationUs &lt;= playbackInfo.positionUs) &amp;&amp; playingPeriodHolder.info.isFinal) &#123; setState(Player.STATE_ENDED); stopRenderers(); // 若之前是缓冲状态，并且可以进入ready状态，则开始渲染。 &#125; else if (playbackInfo.playbackState == Player.STATE_BUFFERING &amp;&amp; shouldTransitionToReadyState(renderersReadyOrEnded)) &#123; setState(Player.STATE_READY); if (playWhenReady) &#123; startRenderers(); &#125; // 已经进入播放状态，但timeline/渲染器没有准备就绪，则进入缓冲状态，并停止渲染器； // 根据官方关于Player.STATE_READY的描述（The player is able to immediately play from its current position.），既然可直接播放，应该是渲染已经就绪了，renderersReadyOrEnded应该为true才对，有点矛盾呀。在官方的commit记录中有如下描述： // - Renderers becoming ready is asynchronous, so the change wasn't well thought through :(. // - This will bring back the possibility of getting stuck in the buffering-but-not-loading anything state. This will need to be addressed in a future CL. &#125; else if (playbackInfo.playbackState == Player.STATE_READY &amp;&amp; !(enabledRenderers.length == 0 ? isTimelineReady() : renderersReadyOrEnded)) &#123; rebuffering = playWhenReady; setState(Player.STATE_BUFFERING); stopRenderers(); &#125; // 检测渲染器在渲染的过程中是否有异常，若有则中断渲染。 // 在每次轮询时，为什么每次都要执行渲染异常检测呢？其commit如下： // On an edge case, player may get stuck when the renderers are ready but the buffer doesn't get full enough because of a fatal error in data source. An example state can be created by starting a live DASH stream and switching between normal and slow network connections. if (playbackInfo.playbackState == Player.STATE_BUFFERING) &#123; for (Renderer renderer : enabledRenderers) &#123; renderer.maybeThrowStreamError(); &#125; &#125; // 若播放器已准备就绪/正在缓冲中，则间隔RENDERING_INTERVAL_MS时间后轮询执行doSomeWork()。 if ((playWhenReady &amp;&amp; playbackInfo.playbackState == Player.STATE_READY) || playbackInfo.playbackState == Player.STATE_BUFFERING) &#123; scheduleNextWork(operationStartTimeMs, RENDERING_INTERVAL_MS); &#125; else if (enabledRenderers.length != 0 &amp;&amp; playbackInfo.playbackState != Player.STATE_ENDED) &#123; // 若播放未结束，则间隔IDLE_INTERVAL_MS时间后执行doSomeWork();可能播放器还未准备就绪/或者playWhenReady = false。此时轮询等待。 scheduleNextWork(operationStartTimeMs, IDLE_INTERVAL_MS); &#125; else &#123; // 停止轮询检测。 handler.removeMessages(MSG_DO_SOME_WORK); &#125; TraceUtil.endSection();&#125; 在以上的过程中执行如下操作： 更新播放的位置； 更新缓冲的位置； 更新播放器当前状态； 渲染视频/音频； 判断播放器当前状态，若播放器在缓冲中，或者已准备就绪（缓冲完毕，可以播放），则轮询执行，一直等到播放器播放结束； 在轮询的过程中检测渲染器是否有异常，若有异常则终止轮询。 在官方的描述中： Once the player has been prepared, playback can be controlled by calling methods on the player. For example setPlayWhenReady can be used to start and pause playback 为什么setPlayWhenReady可以用于播放的暂停和开始呢？ 123public void setPlayWhenReady(boolean playWhenReady) &#123; handler.obtainMessage(MSG_SET_PLAY_WHEN_READY, playWhenReady ? 1 : 0, 0).sendToTarget();&#125; 其详细实现如下： 123456789101112131415161718private void setPlayWhenReadyInternal(boolean playWhenReady) throws ExoPlaybackException &#123; rebuffering = false; this.playWhenReady = playWhenReady; // 停止渲染视频。 if (!playWhenReady) &#123; stopRenderers(); updatePlaybackPositions(); &#125; else &#123; // 若视频渲染已经就绪，可以立即播放，则开始渲染，并轮询。 if (playbackInfo.playbackState == Player.STATE_READY) &#123; startRenderers(); handler.sendEmptyMessage(MSG_DO_SOME_WORK); // 若视频正在缓冲中，则开始轮询检测。 &#125; else if (playbackInfo.playbackState == Player.STATE_BUFFERING) &#123; handler.sendEmptyMessage(MSG_DO_SOME_WORK); &#125; &#125;&#125; 播放的开始和暂停如下所示： 1234567891011121314private void startRenderers() throws ExoPlaybackException &#123; rebuffering = false; mediaClock.start(); for (Renderer renderer : enabledRenderers) &#123; renderer.start(); &#125;&#125;private void stopRenderers() throws ExoPlaybackException &#123; mediaClock.stop(); for (Renderer renderer : enabledRenderers) &#123; ensureStopped(renderer); &#125;&#125; 视频的停止通过如下方式实现： 12345678910111213private void stopInternal(boolean reset, boolean acknowledgeStop) &#123; // 重置（清除MSG_DO_SOME_WORK；停止渲染并创建新的渲染器；清除就绪队列；重置状态；重置mediasource等信息） resetInternal( /* releaseMediaSource= */ true, /* resetPosition= */ reset, /* resetState= */ reset); // 将标志位-1，若标志位位0，则ExoPlayerImpl会重置状态位。 playbackInfoUpdate.incrementPendingOperationAcks( pendingPrepareCount + (acknowledgeStop ? 1 : 0)); pendingPrepareCount = 0; // 通知加载控制器停止； loadControl.onStopped(); // 将播放器状态置为空闲（没有视频源要播放） setState(Player.STATE_IDLE);&#125; 视频播放的简单流程即如上所示，简单的处理过程为： 数据源准备-&gt;媒体渲染-&gt;显示-&gt;停止渲染-&gt;终止(资源释放)。 初步了解ExoPlayer，理解应该有偏差，以上仅是ExoPlayer处理视频播放的一个大致过程，关于视频源如何加载，轨道选择，渲染，缓冲等等，还需要不断深入了解。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>ExoPlayer</tag>
        <tag>视频播放</tag>
        <tag>视频播放流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ExoPlayer简析（一）]]></title>
    <url>%2Fposts%2F5aacfa75%2F</url>
    <content type="text"><![CDATA[ExoPlayer是Google推出的一款非常优秀的视频播放器，具有非常好的灵活性和扩展性。 ExoPlayer主要组件类型关于ExoPlayer的详细介绍可参考官方介绍. 简析的源码基于r2.8.1版本； 主要组件有： MediaSource:定义了将要播放的媒体源数据；（播放时创建） Renderer :渲染媒体数据；（ExoPlayer实例化时创建） TrackSelector:轨道选择器：从MediaSource中选择合适的轨道数据供Renderer渲染；（ExoPlayer实例化时创建） LoadControl:控制何时缓冲媒体数据，以及缓冲多少媒体数据。（ExoPlayer实例化时创建） 通过以上不同的组件，将数据的处理，媒体轨道的选择，媒体数据的渲染及加载单独处理；同时，以上提到的组件分别都是接口，在内部提供默认实现，实例化时可由使用者提供自定义实现。通过以上两点实现业务分离，高度可定制化。 ExoPlayer性能在官方文档性能介绍中提到，使用SurfaceView会比TextureView节省30%的电量，因此推荐使用SurfaceView. Should I use SurfaceView or TextureView?SurfaceView has a number of benefits over TextureView for video playback: Significantly lower power consumption on many devices. More accurate frame timing, resulting in smoother video playback. Support for secure output when playing DRM protected content. SurfaceView should therefore be preferred over TextureView where possible. TextureView should be used only if SurfaceView does not meet your needs. One example is where smooth animations or scrolling of the video surface is required prior to Android N (see How do I get smooth animation/scrolling of video?). For this case, it’s preferable to use TextureView only when SDK_INT is less than 24 (Android N) and SurfaceView otherwise. 在播放音频时推荐使用MediaPlayer，因为MediaPlayer支持audio offload，此特性允许音频的处理运行在一个专用的进程中；而ExoPlayer不支持此特性的原因是因为android fragmework没有公开相应的接口（google有望在未来公开此接口）； ExoPlayer库压缩针对依赖库压缩，通常采用的方式莫过于配置gradle，精简不使用的代码。在官方介绍中有个值得关注的细节：如果播放器仅支持部分特性即可实现功能，则可仅采用支持该特性的代码，不必将全部特性代码都引用。 Specify which Renderer implementations your app needsIf your app uses SimpleExoPlayer, be aware that by default the player’s renderers will be created using DefaultRenderersFactory. DefaultRenderersFactory depends on all of the Renderer implementations provided in the ExoPlayer library, and as a result none of them will be removed by ProGuard. If you know that your app only needs a subset of renderers, you can specify your own RenderersFactory instead. For example, an app that only plays audio can define a factory like: 12345678910111213141516171819202122&gt; private class AudioOnlyRenderersFactory implements RenderersFactory &#123;&gt; &gt; private final Context context;&gt; &gt; public AudioOnlyRenderersFactory(Context context) &#123;&gt; this.context = context;&gt; &#125;&gt; &gt; @Override&gt; public Renderer[] createRenderers(&gt; Handler eventHandler,&gt; VideoRendererEventListener videoRendererEventListener,&gt; AudioRendererEventListener audioRendererEventListener,&gt; TextOutput textRendererOutput,&gt; MetadataOutput metadataRendererOutput,&gt; DrmSessionManager&lt;FrameworkMediaCrypto&gt; drmSessionManager) &#123;&gt; return new Renderer[] &#123;new MediaCodecAudioRenderer(&gt; MediaCodecSelector.DEFAULT, eventHandler, audioRendererEventListener)&#125;;&gt; &#125;&gt; &gt; &#125;&gt; And use it when instantiating SimpleExoPlayer instances, like: 123&gt; SimpleExoPlayer player = ExoPlayerFactory.newSimpleInstance(&gt; new AudioOnlyRenderersFactory(context), trackSelector);&gt; This will allow other Renderer implementations to be removed by ProGuard. In this particular example video, text and metadata renderers are removed. 在精简安装包时，依赖库通常是一个倍感无法下手的问题，以上的处理方式灵活的采用了ProGuard特性，自动去除未引用的代码，是一个可值得借鉴的思路。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>ExoPlayer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LruCache源码思考]]></title>
    <url>%2Fposts%2F7953f905%2F</url>
    <content type="text"><![CDATA[LruCache是内存缓存数据存储的经典方案，该存储结构通过删除最近最少使用的数据，以使最常用数据发挥更有效的作用。 LruCache的特点： 最大数据存储容量的限制； 按照数据的访问顺序排序； 最近最少使用的数据的管理； 良好的灵活性。 源码来源：Android API 25 Platform 最大数据存储的限制最大数据存储的限制是Lru算法开始发挥作用的起点，当数据容量超过设置的最大数据容量时，Lru算法开始发挥作用，删除最近最少使用的数据，直到低于设置的最大容量。 最大数据设置的灵活性： 在创建LruCache对象时，设置默认的最大值； 123456789101112 /** * @param maxSize for caches that do not override &#123;@link #sizeOf&#125;, this is * the maximum number of entries in the cache. For all other caches, * this is the maximum sum of the sizes of the entries in this cache. */public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);&#125; 向外暴露接口设置最大值 一旦最大值变化，重新对已存储的数据大小进行检验，若当前存储的数据大小超过新设置的最大值，则精简缓存. 12345678910111213141516 /** * Sets the size of the cache. * * @param maxSize The new maximum size. */public void resize(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; // 支持线程安全 synchronized (this) &#123; this.maxSize = maxSize; &#125; // 真正的缓存精简由该方法实现，以上做安全校验。 trimToSize(maxSize);&#125; 数据的存储顺序在创建LruCache对象时，直接初始化了LinkedHashMap的数据结构来存储数据，并按照访问顺序来进行排序。 123...this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);... 关于LinkedHashMap 1234567891011121314151617 /** * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the * specified initial capacity, load factor and ordering mode. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @param accessOrder the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for * access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; 通过链表实现数据的有序存储； accessOrder确定了链表中数据的排序方式： false:按照数据的插入顺序存储； true:按照数据的访问顺序存储，最近访问的数据放到链表的末端；若在遍历链表前，没有数据的访问，则按照插入时的顺序遍历。 访问排序的实现： 1234567891011121314151617181920212223242526272829303132// 该方法的最终目的是：把最近访问的元素放到链表最后；// e:最近访问的元素void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMapEntry&lt;K,V&gt; last; // 排序前条件判断：1.是访问排序；2.最后一个元素不是我们要插入的元素 if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMapEntry&lt;K,V&gt; p = (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after; // 1. 重置p节点的尾节点； p.after = null; // 2. 判断p的头节点是否是链表头节点； if (b == null) head = a; else b.after = a; // 3. 判断p的尾节点是否是链表的尾节点； if (a != null) a.before = b; else last = b; // 4. 将p节点连接到链表的尾节点； if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; // 5. 将p节点赋予到尾节点； tail = p; ++modCount; &#125;&#125; 最近最少使用的数据的删除Q：哪个元素是最近最少使用的元素？ A：按照访问排序的实现，访问排序会将最近访问的元素放在链表的底部，那头部的节点就是最近最少使用的元素。 Q：删除最近最少使用的元素的时机？ A： 1. 当插入新元素，链表的大小超过了设置的最大容量时； 12345678910111213141516171819202122232425262728293031 /** * Caches &#123;@code value&#125; for &#123;@code key&#125;. The value is moved to the head of * the queue. * * @return the previous value mapped by &#123;@code key&#125;. */public final V put(K key, V value) &#123; if (key == null || value == null) &#123; throw new NullPointerException("key == null || value == null"); &#125; V previous; // 使用对象锁，支持多线程操作； synchronized (this) &#123; putCount++; // 增加被添加元素的大小； size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) &#123; // 减小被替换元素的大小。 size -= safeSizeOf(key, previous); &#125; &#125; // 通知链表中的元素被删除（得到删除的通知后，我们可以针对被删除的元素做很多事情：释放资源等） if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; // 插入元素后，检测是否超过了最大存储空间。 trimToSize(maxSize); return previous;&#125; 手动调用trimToSize释放空间时； 最近最少元素的删除都回归到了trimToSize方法，它是如何实现的？ 1234567891011121314151617181920212223242526272829303132333435363738 /** * Remove the eldest entries until the total of remaining entries is at or * below the requested size. * * @param maxSize the maximum size of the cache before returning. May be -1 * to evict even 0-sized elements. */public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; // size最小是0，maxSize可能 &lt; 0(清空列表)，因此有必要再对toEvict是否为空进行判断; if (size &lt;= maxSize) &#123; // 直到当前空间大小小于设置的最大值，则退出循环； break; &#125; // 获取最近最少使用的元素（核心） Map.Entry&lt;K, V&gt; toEvict = map.eldest(); if (toEvict == null) &#123; // 链表元素清除完毕，退出循环。 break; &#125; // 删除元素，释放空间； key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; &#125; // 通知元素被删除 entryRemoved(true, key, value, null); &#125;&#125; 良好的灵活性 数据结构采用范型，实现多类型的数据存储； 通过复写sizeOf实现元素大小的计算可自定义； 通过复写create实现空value时的可自定义； 通过复写entryRemoved实现被删除元素的可监听性； 通过resize接口实现最大存储空间的可定制性； 通过snapshot获取当前链表的快照； 通过toString可简单查看获取缓存元素时的击中率。 从单个元素进入链表的之后的整个周期内，元素的清除和替换我们都可以观察到变化；甚至在获取元素为空时，我们都可以创建新的元素返回；从单个元素到整个链表，再到击中率/失败率的统计，都具有完善的体系。LruCache虽然代码量很小，但具有优秀的灵活性。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>LruCache</tag>
        <tag>源码</tag>
        <tag>分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于源码分析的思考]]></title>
    <url>%2Fposts%2Fe9048e60%2F</url>
    <content type="text"><![CDATA[关于博客中的源码分析，我希望能在程序设计和解决问题的角度去分析源码，以便这些源码的设计思想能在后续的开发中有效利用。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2Fposts%2Fd98ef1d2%2F</url>
    <content type="text"><![CDATA[给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 方法一思路：根据冒泡的方式，遍历数组，两数字之和等于目标值则找到。 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; if (nums == null || nums.length &lt;= 1) &#123; return null; &#125; for (int i = 0; i &lt; nums.length - 1; i ++)&#123; for (int j = i +1; j &lt; nums.length; j ++) &#123; if (nums[i] + nums[j] == target) &#123; return new int[]&#123;i, j&#125;; &#125; &#125; &#125; return null; &#125;&#125; 总结：上述方式遍历2次数组，效率不高； 方法二思路：根据target，数组遍历当前值，查找差值是否在数组中。 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; if (nums == null || nums.length &lt;= 1) &#123; return null; &#125; Map&lt;Integer, Integer&gt; filter = new HashMap(); for (int i = 0; i &lt; nums.length; i ++)&#123; if (filter.containsKey(target - nums[i])) &#123; return new int[]&#123;i, filter.get(target - nums[i])&#125;; &#125; filter.put(nums[i], i); &#125; return null; &#125;&#125; 总结：数组仅遍历一次，效率提高；利用HashMap实现值和索引的配对。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>两数之和</tag>
      </tags>
  </entry>
</search>
