<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《无声告白》]]></title>
    <url>%2F2018%2F06%2F12%2F%E3%80%8A%E6%97%A0%E5%A3%B0%E5%91%8A%E7%99%BD%E3%80%8B%2F</url>
    <content type="text"><![CDATA[我们终此一生，就是要摆脱他人的期待，找到真正的自己！ 我们终此一生，就是要摆脱他人的期待，找到真正的自己！ 莉迪亚的生命很短暂，在她短暂的生命终点，她找到了真正的自己。如果收获一个果实需要付出很多，那么这个代价有点太沉重了。 全书围绕莉迪亚的死亡展开描述，读起来让人倍感压抑。但又于这压抑中，慢慢的竟有生的希望，犹如老树发芽。 在莉迪亚的身上，他寄托了父亲和母亲未达成的梦想，而这梦想犹如淹死她的湖水将她一步步拖入深渊，最后不堪重负。在杰克的引导下，她最终找到了自己，但却没有游出象征着她迈出人生重要一步的湖泊。作者多次强调，湖水犹如父母的梦想，将她包围。她最终溺亡，是否暗示了她即使游出湖，也无法摆脱父母的期待，做真正的自己。令人欣慰的是，她找到了真正的自己。 在目前中国的大多数家庭中，很多的父母将其未完成的梦想寄托于儿女，希望儿女能实现。每个人都有自己的一生，导演和编剧都是自己，你演不好自己的戏，也不要让别人来替你演，因为他们有自己的舞台。 莉迪亚的溺亡，犹如初春的柳条狠狠的甩在宁静的湖面，击飞浮尘的同时，也露出了清澈的湖面，该书的最后，家里的每一个人都找到了真正的自己。 书中让我惊讶的是儿女们敏锐的洞察力，他们洞悉隐藏在表面的真相，并试图用自己微弱的力量温暖这个家。 本书值得一看，尤其在于对儿女教育观念的转变及对自身未来的探索。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>无声告白</tag>
        <tag>书</tag>
        <tag>有感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ExoPlayer视频播放流程简析（二）]]></title>
    <url>%2F2018%2F06%2F11%2FExoPlayer%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%B5%81%E7%A8%8B%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ExoPlayer播放视频的流程是什么样的？在整个视频播放的过程中，它是如何进行的？ ExoPlayer在设计视频播放时定义了很多视频相关的接口，以使该框架灵活性和扩展性更好，在主要的Player和ExoPlayer中都定义了哪些通用的接口和方法呢？ 源码参考r2.8.1版本。 Player定义的功能： 视频事件监听接口EventListener 加载状态监听； 播放状态监听； 时间轴变化； 轨道变化； 视频参数变化； seek状态变化； 重放模式监听； 播放异常信息监听； 视频组件； 字幕组件； 视频播放控制（开始，暂停，停止）； 视频参数设置； 广告相关； ExoPlayer定义的功能：ExoPlayer实现了Player,在Player功能的基础上增加了如下特性： 其它线程和播放线程的通信； 媒体资源的准备接口； Player中定义的都是和视频本身事件相关的接口；而在ExoPlayer中定义了和上层通信的接口以及为上层视频播放提供资源的接口；ExoPlayer为上层提供了交互的桥梁； ExoPlayerImpl功能实现：ExoPlayerImpl是ExoPlayer的实现，但它仅提供了简单实现： 对外提供视频播放的基本信息； 对ExoPlayer的真正实现ExoPlayerImplInternal的封装; Q: 为什么不由ExoPlayerImpl直接提供对ExoPlayer的实现呢？反而交由ExoPlayerImplInternal来完成。 A: 在ExoPlayerImplInternal的内部实现中，是通过handler机制将视频播放的事件发送到独立的线程中运行。由ExoPlayerImplInternal来完全处理播放相关事件的发送和实现；通过该方式达到业务的实现和状态（提供给上层的接口）分离。接口的使用者根本不用关心其内部是如何实现的，并且也不应该将其实现暴漏给接口调用者。后续若有需求/实现的变更，仅修改对应的部分即可，互不影响。 ExoPlayerImplInternal部分实现 在构建ExoPlayerImplInternal对象时，传入了渲染器，轨道选择器， 加载控制器等参数用于为后续的视频播放提供支持； 通过prepare方法为视频播放提供播放的视频源，内部实现是通过handler将该操作发送到播放线程执行， 12345public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) &#123; handler .obtainMessage(MSG_PREPARE, resetPosition ? 1 : 0, resetState ? 1 : 0, mediaSource) .sendToTarget();&#125; 在播放线程中接收消息： 1234567891011public boolean handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_PREPARE: prepareInternal( (MediaSource) msg.obj, /* resetPosition= */ msg.arg1 != 0, /* resetState= */ msg.arg2 != 0); break; ... &#125;&#125; 处理消息： 1234567891011121314151617private void prepareInternal(MediaSource mediaSource, boolean resetPosition, boolean resetState) &#123; // 标示进入就绪状态的个数； // 若该值&gt;0,则认为针对新的MediaSource的timeline还没有初始化完成，部分操作将进入就绪状态。 // 当timeline更新或者plyer stop时会被重置。 pendingPrepareCount++; // 重置（清除MSG_DO_SOME_WORK；停止渲染并创建新的渲染器；清除就绪队列；重置状态；重置mediasource等信息） resetInternal(/* releaseMediaSource= */ true, resetPosition, resetState); // 通知重置加载控制器 loadControl.onPrepared(); this.mediaSource = mediaSource; // 由于有了新的MediaSource，需要重置状态； setState(Player.STATE_BUFFERING); // 通知MediaSource的实现准备数据源； mediaSource.prepareSource(player, /* isTopLevelSource= */ true, /* listener= */ this); // 通知播放线程开始工作。 handler.sendEmptyMessage(MSG_DO_SOME_WORK);&#125; 准备工作完成后，后续的工作交给了MSG_DO_SOME_WORK，最终实现为doSomeWork: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091private void doSomeWork() throws ExoPlaybackException, IOException &#123; long operationStartTimeMs = clock.uptimeMillis(); // 更新缓冲/播放时间 updatePeriods(); // 若队列中没有需要播放的资源，则在间隔PREPARING_SOURCE_INTERVAL_MS时间后重复检测。 if (!queue.hasPlayingPeriod()) &#123; // We're still waiting for the first period to be prepared. maybeThrowPeriodPrepareError(); scheduleNextWork(operationStartTimeMs, PREPARING_SOURCE_INTERVAL_MS); return; &#125; MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod(); TraceUtil.beginSection("doSomeWork"); // 更新播放（渲染）/缓冲位置； updatePlaybackPositions(); long rendererPositionElapsedRealtimeUs = SystemClock.elapsedRealtime() * 1000; // 丢弃指定位置/关键帧之前的缓冲； playingPeriodHolder.mediaPeriod.discardBuffer(playbackInfo.positionUs - backBufferDurationUs,retainBackBufferFromKeyframe); boolean renderersEnded = true; boolean renderersReadyOrEnded = true; // 此处检查渲染是否就绪，及渲染是否结束； for (Renderer renderer : enabledRenderers) &#123; // TODO: Each renderer should return the maximum delay before which it wishes to be called // again. The minimum of these values should then be used as the delay before the next // invocation of this method. renderer.render(rendererPositionUs, rendererPositionElapsedRealtimeUs); renderersEnded = renderersEnded &amp;&amp; renderer.isEnded(); // Determine whether the renderer is ready (or ended). We override to assume the renderer is // ready if it needs the next sample stream. This is necessary to avoid getting stuck if // tracks in the current period have uneven durations. See: // https://github.com/google/ExoPlayer/issues/1874 boolean rendererReadyOrEnded = renderer.isReady() || renderer.isEnded() || rendererWaitingForNextStream(renderer); if (!rendererReadyOrEnded) &#123; renderer.maybeThrowStreamError(); &#125; renderersReadyOrEnded = renderersReadyOrEnded &amp;&amp; rendererReadyOrEnded; &#125; if (!renderersReadyOrEnded) &#123; maybeThrowPeriodPrepareError(); &#125; long playingPeriodDurationUs = playingPeriodHolder.info.durationUs; // 所有的渲染已经结束则停止渲染（@todo playingPeriodDurationUs &lt;= playbackInfo.positionUs ？） if (renderersEnded &amp;&amp; (playingPeriodDurationUs == C.TIME_UNSET || playingPeriodDurationUs &lt;= playbackInfo.positionUs) &amp;&amp; playingPeriodHolder.info.isFinal) &#123; setState(Player.STATE_ENDED); stopRenderers(); // 若之前是缓冲状态，并且可以进入ready状态，则开始渲染。 &#125; else if (playbackInfo.playbackState == Player.STATE_BUFFERING &amp;&amp; shouldTransitionToReadyState(renderersReadyOrEnded)) &#123; setState(Player.STATE_READY); if (playWhenReady) &#123; startRenderers(); &#125; // 已经进入播放状态，但timeline/渲染器没有准备就绪，则进入缓冲状态，并停止渲染器； // 根据官方关于Player.STATE_READY的描述（The player is able to immediately play from its current position.），既然可直接播放，应该是渲染已经就绪了，renderersReadyOrEnded应该为true才对，有点矛盾呀。在官方的commit记录中有如下描述： // - Renderers becoming ready is asynchronous, so the change wasn't well thought through :(. // - This will bring back the possibility of getting stuck in the buffering-but-not-loading anything state. This will need to be addressed in a future CL. &#125; else if (playbackInfo.playbackState == Player.STATE_READY &amp;&amp; !(enabledRenderers.length == 0 ? isTimelineReady() : renderersReadyOrEnded)) &#123; rebuffering = playWhenReady; setState(Player.STATE_BUFFERING); stopRenderers(); &#125; // 检测渲染器在渲染的过程中是否有异常，若有则中断渲染。 // 在每次轮询时，为什么每次都要执行渲染异常检测呢？其commit如下： // On an edge case, player may get stuck when the renderers are ready but the buffer doesn't get full enough because of a fatal error in data source. An example state can be created by starting a live DASH stream and switching between normal and slow network connections. if (playbackInfo.playbackState == Player.STATE_BUFFERING) &#123; for (Renderer renderer : enabledRenderers) &#123; renderer.maybeThrowStreamError(); &#125; &#125; // 若播放器已准备就绪/正在缓冲中，则间隔RENDERING_INTERVAL_MS时间后轮询执行doSomeWork()。 if ((playWhenReady &amp;&amp; playbackInfo.playbackState == Player.STATE_READY) || playbackInfo.playbackState == Player.STATE_BUFFERING) &#123; scheduleNextWork(operationStartTimeMs, RENDERING_INTERVAL_MS); &#125; else if (enabledRenderers.length != 0 &amp;&amp; playbackInfo.playbackState != Player.STATE_ENDED) &#123; // 若播放未结束，则间隔IDLE_INTERVAL_MS时间后执行doSomeWork();可能播放器还未准备就绪/或者playWhenReady = false。此时轮询等待。 scheduleNextWork(operationStartTimeMs, IDLE_INTERVAL_MS); &#125; else &#123; // 停止轮询检测。 handler.removeMessages(MSG_DO_SOME_WORK); &#125; TraceUtil.endSection();&#125; 在以上的过程中执行如下操作： 更新播放的位置； 更新缓冲的位置； 更新播放器当前状态； 渲染视频/音频； 判断播放器当前状态，若播放器在缓冲中，或者已准备就绪（缓冲完毕，可以播放），则轮询执行，一直等到播放器播放结束； 在轮询的过程中检测渲染器是否有异常，若有异常则终止轮询。 在官方的描述中： Once the player has been prepared, playback can be controlled by calling methods on the player. For example setPlayWhenReady can be used to start and pause playback 为什么setPlayWhenReady可以用于播放的暂停和开始呢？ 123public void setPlayWhenReady(boolean playWhenReady) &#123; handler.obtainMessage(MSG_SET_PLAY_WHEN_READY, playWhenReady ? 1 : 0, 0).sendToTarget();&#125; 其详细实现如下： 123456789101112131415161718private void setPlayWhenReadyInternal(boolean playWhenReady) throws ExoPlaybackException &#123; rebuffering = false; this.playWhenReady = playWhenReady; // 停止渲染视频。 if (!playWhenReady) &#123; stopRenderers(); updatePlaybackPositions(); &#125; else &#123; // 若视频渲染已经就绪，可以立即播放，则开始渲染，并轮询。 if (playbackInfo.playbackState == Player.STATE_READY) &#123; startRenderers(); handler.sendEmptyMessage(MSG_DO_SOME_WORK); // 若视频正在缓冲中，则开始轮询检测。 &#125; else if (playbackInfo.playbackState == Player.STATE_BUFFERING) &#123; handler.sendEmptyMessage(MSG_DO_SOME_WORK); &#125; &#125;&#125; 播放的开始和暂停如下所示： 1234567891011121314private void startRenderers() throws ExoPlaybackException &#123; rebuffering = false; mediaClock.start(); for (Renderer renderer : enabledRenderers) &#123; renderer.start(); &#125;&#125;private void stopRenderers() throws ExoPlaybackException &#123; mediaClock.stop(); for (Renderer renderer : enabledRenderers) &#123; ensureStopped(renderer); &#125;&#125; 视频的停止通过如下方式实现： 12345678910111213private void stopInternal(boolean reset, boolean acknowledgeStop) &#123; // 重置（清除MSG_DO_SOME_WORK；停止渲染并创建新的渲染器；清除就绪队列；重置状态；重置mediasource等信息） resetInternal( /* releaseMediaSource= */ true, /* resetPosition= */ reset, /* resetState= */ reset); // 将标志位-1，若标志位位0，则ExoPlayerImpl会重置状态位。 playbackInfoUpdate.incrementPendingOperationAcks( pendingPrepareCount + (acknowledgeStop ? 1 : 0)); pendingPrepareCount = 0; // 通知加载控制器停止； loadControl.onStopped(); // 将播放器状态置为空闲（没有视频源要播放） setState(Player.STATE_IDLE);&#125; 视频播放的简单流程即如上所示，简单的处理过程为： 数据源准备-&gt;媒体渲染-&gt;显示-&gt;停止渲染-&gt;终止(资源释放)。 初步了解ExoPlayer，理解应该有偏差，以上仅是ExoPlayer处理视频播放的一个大致过程，关于视频源如何加载，轨道选择，渲染，缓冲等等，还需要不断深入了解。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>ExoPlayer</tag>
        <tag>视频播放</tag>
        <tag>视频播放流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ExoPlayer简析（一）]]></title>
    <url>%2F2018%2F06%2F08%2FExoPlayer%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ExoPlayer是Google推出的一款非常优秀的视频播放器，具有非常好的灵活性和扩展性。 ExoPlayer主要组件类型关于ExoPlayer的详细介绍可参考官方介绍. 简析的源码基于r2.8.1版本； 主要组件有： MediaSource:定义了将要播放的媒体源数据；（播放时创建） Renderer :渲染媒体数据；（ExoPlayer实例化时创建） TrackSelector:轨道选择器：从MediaSource中选择合适的轨道数据供Renderer渲染；（ExoPlayer实例化时创建） LoadControl:控制何时缓冲媒体数据，以及缓冲多少媒体数据。（ExoPlayer实例化时创建） 通过以上不同的组件，将数据的处理，媒体轨道的选择，媒体数据的渲染及加载单独处理；同时，以上提到的组件分别都是接口，在内部提供默认实现，实例化时可由使用者提供自定义实现。通过以上两点实现业务分离，高度可定制化。 ExoPlayer性能在官方文档性能介绍中提到，使用SurfaceView会比TextureView节省30%的电量，因此推荐使用SurfaceView. Should I use SurfaceView or TextureView?SurfaceView has a number of benefits over TextureView for video playback: Significantly lower power consumption on many devices. More accurate frame timing, resulting in smoother video playback. Support for secure output when playing DRM protected content. SurfaceView should therefore be preferred over TextureView where possible. TextureView should be used only if SurfaceView does not meet your needs. One example is where smooth animations or scrolling of the video surface is required prior to Android N (see How do I get smooth animation/scrolling of video?). For this case, it’s preferable to use TextureView only when SDK_INT is less than 24 (Android N) and SurfaceView otherwise. 在播放音频时推荐使用MediaPlayer，因为MediaPlayer支持audio offload，此特性允许音频的处理运行在一个专用的进程中；而ExoPlayer不支持此特性的原因是因为android fragmework没有公开相应的接口（google有望在未来公开此接口）； ExoPlayer库压缩针对依赖库压缩，通常采用的方式莫过于配置gradle，精简不使用的代码。在官方介绍中有个值得关注的细节：如果播放器仅支持部分特性即可实现功能，则可仅采用支持该特性的代码，不必将全部特性代码都引用。 Specify which Renderer implementations your app needsIf your app uses SimpleExoPlayer, be aware that by default the player’s renderers will be created using DefaultRenderersFactory. DefaultRenderersFactory depends on all of the Renderer implementations provided in the ExoPlayer library, and as a result none of them will be removed by ProGuard. If you know that your app only needs a subset of renderers, you can specify your own RenderersFactory instead. For example, an app that only plays audio can define a factory like: 12345678910111213141516171819202122&gt; private class AudioOnlyRenderersFactory implements RenderersFactory &#123;&gt; &gt; private final Context context;&gt; &gt; public AudioOnlyRenderersFactory(Context context) &#123;&gt; this.context = context;&gt; &#125;&gt; &gt; @Override&gt; public Renderer[] createRenderers(&gt; Handler eventHandler,&gt; VideoRendererEventListener videoRendererEventListener,&gt; AudioRendererEventListener audioRendererEventListener,&gt; TextOutput textRendererOutput,&gt; MetadataOutput metadataRendererOutput,&gt; DrmSessionManager&lt;FrameworkMediaCrypto&gt; drmSessionManager) &#123;&gt; return new Renderer[] &#123;new MediaCodecAudioRenderer(&gt; MediaCodecSelector.DEFAULT, eventHandler, audioRendererEventListener)&#125;;&gt; &#125;&gt; &gt; &#125;&gt; And use it when instantiating SimpleExoPlayer instances, like: 123&gt; SimpleExoPlayer player = ExoPlayerFactory.newSimpleInstance(&gt; new AudioOnlyRenderersFactory(context), trackSelector);&gt; This will allow other Renderer implementations to be removed by ProGuard. In this particular example video, text and metadata renderers are removed. 在精简安装包时，依赖库通常是一个倍感无法下手的问题，以上的处理方式灵活的采用了ProGuard特性，自动去除未引用的代码，是一个可值得借鉴的思路。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>ExoPlayer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LruCache源码思考]]></title>
    <url>%2F2018%2F05%2F17%2FLruCache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[LruCache是内存缓存数据存储的经典方案，该存储结构通过删除最近最少使用的数据，以使最常用数据发挥更有效的作用。 LruCache的特点： 最大数据存储容量的限制； 按照数据的访问顺序排序； 最近最少使用的数据的管理； 良好的灵活性。 源码来源：Android API 25 Platform 最大数据存储的限制最大数据存储的限制是Lru算法开始发挥作用的起点，当数据容量超过设置的最大数据容量时，Lru算法开始发挥作用，删除最近最少使用的数据，直到低于设置的最大容量。 最大数据设置的灵活性： 在创建LruCache对象时，设置默认的最大值； 123456789101112 /** * @param maxSize for caches that do not override &#123;@link #sizeOf&#125;, this is * the maximum number of entries in the cache. For all other caches, * this is the maximum sum of the sizes of the entries in this cache. */public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);&#125; 向外暴露接口设置最大值 一旦最大值变化，重新对已存储的数据大小进行检验，若当前存储的数据大小超过新设置的最大值，则精简缓存. 12345678910111213141516 /** * Sets the size of the cache. * * @param maxSize The new maximum size. */public void resize(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; // 支持线程安全 synchronized (this) &#123; this.maxSize = maxSize; &#125; // 真正的缓存精简由该方法实现，以上做安全校验。 trimToSize(maxSize);&#125; 数据的存储顺序在创建LruCache对象时，直接初始化了LinkedHashMap的数据结构来存储数据，并按照访问顺序来进行排序。 123...this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);... 关于LinkedHashMap 1234567891011121314151617 /** * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the * specified initial capacity, load factor and ordering mode. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @param accessOrder the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for * access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; 通过链表实现数据的有序存储； accessOrder确定了链表中数据的排序方式： false:按照数据的插入顺序存储； true:按照数据的访问顺序存储，最近访问的数据放到链表的末端；若在遍历链表前，没有数据的访问，则按照插入时的顺序遍历。 访问排序的实现： 1234567891011121314151617181920212223242526272829303132// 该方法的最终目的是：把最近访问的元素放到链表最后；// e:最近访问的元素void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMapEntry&lt;K,V&gt; last; // 排序前条件判断：1.是访问排序；2.最后一个元素不是我们要插入的元素 if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMapEntry&lt;K,V&gt; p = (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after; // 1. 重置p节点的尾节点； p.after = null; // 2. 判断p的头节点是否是链表头节点； if (b == null) head = a; else b.after = a; // 3. 判断p的尾节点是否是链表的尾节点； if (a != null) a.before = b; else last = b; // 4. 将p节点连接到链表的尾节点； if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; // 5. 将p节点赋予到尾节点； tail = p; ++modCount; &#125;&#125; 最近最少使用的数据的删除Q：哪个元素是最近最少使用的元素？ A：按照访问排序的实现，访问排序会将最近访问的元素放在链表的底部，那头部的节点就是最近最少使用的元素。 Q：删除最近最少使用的元素的时机？ A： 1. 当插入新元素，链表的大小超过了设置的最大容量时； 12345678910111213141516171819202122232425262728293031 /** * Caches &#123;@code value&#125; for &#123;@code key&#125;. The value is moved to the head of * the queue. * * @return the previous value mapped by &#123;@code key&#125;. */public final V put(K key, V value) &#123; if (key == null || value == null) &#123; throw new NullPointerException("key == null || value == null"); &#125; V previous; // 使用对象锁，支持多线程操作； synchronized (this) &#123; putCount++; // 增加被添加元素的大小； size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) &#123; // 减小被替换元素的大小。 size -= safeSizeOf(key, previous); &#125; &#125; // 通知链表中的元素被删除（得到删除的通知后，我们可以针对被删除的元素做很多事情：释放资源等） if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; // 插入元素后，检测是否超过了最大存储空间。 trimToSize(maxSize); return previous;&#125; 手动调用trimToSize释放空间时； 最近最少元素的删除都回归到了trimToSize方法，它是如何实现的？ 1234567891011121314151617181920212223242526272829303132333435363738 /** * Remove the eldest entries until the total of remaining entries is at or * below the requested size. * * @param maxSize the maximum size of the cache before returning. May be -1 * to evict even 0-sized elements. */public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; // size最小是0，maxSize可能 &lt; 0(清空列表)，因此有必要再对toEvict是否为空进行判断; if (size &lt;= maxSize) &#123; // 直到当前空间大小小于设置的最大值，则退出循环； break; &#125; // 获取最近最少使用的元素（核心） Map.Entry&lt;K, V&gt; toEvict = map.eldest(); if (toEvict == null) &#123; // 链表元素清除完毕，退出循环。 break; &#125; // 删除元素，释放空间； key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; &#125; // 通知元素被删除 entryRemoved(true, key, value, null); &#125;&#125; 良好的灵活性 数据结构采用范型，实现多类型的数据存储； 通过复写sizeOf实现元素大小的计算可自定义； 通过复写create实现空value时的可自定义； 通过复写entryRemoved实现被删除元素的可监听性； 通过resize接口实现最大存储空间的可定制性； 通过snapshot获取当前链表的快照； 通过toString可简单查看获取缓存元素时的击中率。 从单个元素进入链表的之后的整个周期内，元素的清除和替换我们都可以观察到变化；甚至在获取元素为空时，我们都可以创建新的元素返回；从单个元素到整个链表，再到击中率/失败率的统计，都具有完善的体系。LruCache虽然代码量很小，但具有优秀的灵活性。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>LruCache</tag>
        <tag>源码</tag>
        <tag>分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于源码分析的思考]]></title>
    <url>%2F2018%2F05%2F17%2F%E5%85%B3%E4%BA%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[关于博客中的源码分析，我希望能在程序设计和解决问题的角度去分析源码，以便这些源码的设计思想能在后续的开发中有效利用。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F2018%2F04%2F25%2Ftwo-sum%2F</url>
    <content type="text"><![CDATA[给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 方法一思路：根据冒泡的方式，遍历数组，两数字之和等于目标值则找到。 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; if (nums == null || nums.length &lt;= 1) &#123; return null; &#125; for (int i = 0; i &lt; nums.length - 1; i ++)&#123; for (int j = i +1; j &lt; nums.length; j ++) &#123; if (nums[i] + nums[j] == target) &#123; return new int[]&#123;i, j&#125;; &#125; &#125; &#125; return null; &#125;&#125; 总结：上述方式遍历2次数组，效率不高； 方法二思路：根据target，数组遍历当前值，查找差值是否在数组中。 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; if (nums == null || nums.length &lt;= 1) &#123; return null; &#125; Map&lt;Integer, Integer&gt; filter = new HashMap(); for (int i = 0; i &lt; nums.length; i ++)&#123; if (filter.containsKey(target - nums[i])) &#123; return new int[]&#123;i, filter.get(target - nums[i])&#125;; &#125; filter.put(nums[i], i); &#125; return null; &#125;&#125; 总结：数组仅遍历一次，效率提高；利用HashMap实现值和索引的配对。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>两数之和</tag>
      </tags>
  </entry>
</search>
